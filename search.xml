<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo 博客基础操作</title>
    <url>/pipixia.github.io/2020/06/17/hexo-%E5%8D%9A%E5%AE%A2%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="1-启动博客"><a href="#1-启动博客" class="headerlink" title="1.启动博客"></a>1.启动博客</h3><p><code>hexo s</code></p>
<h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><p><code>hexo g</code></p>
<h3 id="3-发布"><a href="#3-发布" class="headerlink" title="3.发布"></a>3.发布</h3><p><code>hexo d</code></p>
<h3 id="4-新建文章"><a href="#4-新建文章" class="headerlink" title="4.新建文章"></a>4.新建文章</h3><p><code>hexo new &lt;文章标题&gt; # 可以简写hexo n &lt;文章标题&gt;</code></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>css中div的各大宽度,高度</title>
    <url>/pipixia.github.io/2019/12/09/css%E4%B8%AD%E7%9A%84%E5%90%84%E5%A4%A7%E5%AE%BD%E5%BA%A6/</url>
    <content><![CDATA[<p>css 盒子模型是由内容区域，内边距，边框，外边距组成</p>
<p><img src="/pipixia.github.io/images/box/box.png" alt=""></p>
<h2 id="offsetWidth-offsetHeight"><a href="#offsetWidth-offsetHeight" class="headerlink" title="offsetWidth + offsetHeight"></a>offsetWidth + offsetHeight</h2><p>offsetWidth：内容区域 width + 左右 padding + 左右 border-width<br>offsetHeight：内容区域 height + 上下 padding + 上下 border-width</p>
<p><img src="/pipixia.github.io/images/box/offset.png" alt=""></p>
<h2 id="clientWidth-clientHeight"><a href="#clientWidth-clientHeight" class="headerlink" title="clientWidth + clientHeight"></a>clientWidth + clientHeight</h2><p>clientWidth：内容区域 width + 左右 padding<br>clientHeight：内容区域 width + 上线 padding</p>
<p><img src="/pipixia.github.io/images/box/client.png" alt=""></p>
<h2 id="scrollWidht-scrollHeight"><a href="#scrollWidht-scrollHeight" class="headerlink" title="scrollWidht + scrollHeight"></a>scrollWidht + scrollHeight</h2><p>scrollWidht：内容真实区域的宽度，在没有滚动条时，等于 clientWidth。<br>scrollHeight： 元素内容真实的高度，在没有滚动条时，等于 clientHeight</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现数据与视图的双向绑定</title>
    <url>/pipixia.github.io/2019/12/06/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%86%E5%9B%BE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="实现思路-Object-defineProperty"><a href="#实现思路-Object-defineProperty" class="headerlink" title="实现思路 Object.defineProperty"></a>实现思路 Object.defineProperty</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data &#x3D; &#123;</span><br><span class="line">   age: 10</span><br><span class="line"> &#125;;</span><br><span class="line"> Object.defineProperty(data, &#39;age&#39;, &#123;</span><br><span class="line">   get() &#123;</span><br><span class="line">     console.log(&#39;我被获取的了&#39;);</span><br><span class="line">     return this.age;</span><br><span class="line">   &#125;,</span><br><span class="line">   set(newValue) &#123;</span><br><span class="line">     console.log(&#39;我被设置了&#39;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> let a &#x3D; data.age;</span><br><span class="line"> data.age &#x3D; 20;</span><br></pre></td></tr></table></figure>

<p>我们定义一个 data 对象，为他的 age 属性定义 get，set 方法，此时我们去给 a 赋值时便会调用 get 方法，而为 data.age 赋值时，会调用 set 方法，因此利用这个我们便可以来实现简单的双向绑定了，以 vue 为例。</p>
<h2 id="创建-myVue-js-用来创建属于我们自己的-vue-对象"><a href="#创建-myVue-js-用来创建属于我们自己的-vue-对象" class="headerlink" title="创建 myVue.js 用来创建属于我们自己的 vue 对象"></a>创建 myVue.js 用来创建属于我们自己的 vue 对象</h2><p>为了将我们创建的对象里面的属性全部注册到 Object.defineProperty 中，我们创建方法 observable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function observable(obj) &#123;</span><br><span class="line">  if (!obj || Object.prototype.toString.call(obj) !&#x3D;&#x3D; &#39;[object object]&#39;) return;</span><br><span class="line">  let keys &#x3D; Object.keys(obj);</span><br><span class="line">  keys.forEach((key) &#x3D;&gt; &#123;</span><br><span class="line">    handleDefine(obj, key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleDefine(obj, key) &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      console.log(&#96;$&#123;key&#125;获取到了&#96;);</span><br><span class="line">      return this[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">      console.log(&#96;$&#123;key&#125;赋值$&#123;value&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建-index-html-来渲染我们的视图并观察效果"><a href="#创建-index-html-来渲染我们的视图并观察效果" class="headerlink" title="创建 index.html 来渲染我们的视图并观察效果"></a>创建 index.html 来渲染我们的视图并观察效果</h2><p>将 handle.js 引入 index.html 中<br>在 index.html 定义一个 data 对象，并创建对应的 input 和视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">      &lt;p&gt;name:&lt;span data-view&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;age:&lt;span data-view&#x3D;&quot;age&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      name:&lt;input data-model&#x3D;&quot;name&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">      age:&lt;input data-model&#x3D;&quot;age&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name:&#39;pipixia&#39;,</span><br><span class="line">    age:10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为我们需要的-data-model-对象注册-input-事件"><a href="#为我们需要的-data-model-对象注册-input-事件" class="headerlink" title="为我们需要的 data-model 对象注册 input 事件"></a>为我们需要的 data-model 对象注册 input 事件</h2><p>为带有 data-model 属性的标签，注册 input，并创建 myVue 类，el 代表我们双向绑定生效的标签块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取所有的model对象并为它们注册input事件</span><br><span class="line"></span><br><span class="line">function handleDomInput(el, data) &#123;</span><br><span class="line">  let nodeList &#x3D; document.querySelectorAll(&#96;$&#123;el&#125; [data-model]&#96;);</span><br><span class="line">  nodeList.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    let key &#x3D; item.dataset.model;</span><br><span class="line">    item.addEventListener(&#39;input&#39;, function(node) &#123;</span><br><span class="line">      data[key] &#x3D; node.target.value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新建自己vue类</span><br><span class="line">class myVue &#123;</span><br><span class="line">  constructor(&#123; el, data &#125;) &#123;</span><br><span class="line">    this.el &#x3D; el;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">    &#x2F;&#x2F;分发双向绑定事件</span><br><span class="line">    observable(this.data);</span><br><span class="line">    &#x2F;&#x2F;注册input事件</span><br><span class="line">    handleDomInput(this.el, this.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将改变的数据渲染到视图中"><a href="#将改变的数据渲染到视图中" class="headerlink" title="将改变的数据渲染到视图中"></a>将改变的数据渲染到视图中</h2><p>这一步操作，我们就可以利用 Object.defineProperty 中的 set 事件来操作</p>
<h3 id="创建赋值的方法"><a href="#创建赋值的方法" class="headerlink" title="创建赋值的方法"></a>创建赋值的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取所有的view对象并为他们复职</span><br><span class="line">function handelDomView(key, value, el) &#123;</span><br><span class="line">  let node &#x3D; document.querySelectorAll(&#96;$&#123;el&#125; [data-view &#x3D; $&#123;key&#125;]&#96;);</span><br><span class="line">  node.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    item.innerText &#x3D; value;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将方法加入-Object-defineProperty-中并将-el-传入-observable-中"><a href="#将方法加入-Object-defineProperty-中并将-el-传入-observable-中" class="headerlink" title="将方法加入 Object.defineProperty 中并将 el 传入 observable 中"></a>将方法加入 Object.defineProperty 中并将 el 传入 observable 中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handleDefine(obj, key, el) &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return this[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">      handelDomView(key, value, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取所有的view对象并为他们复职</span><br><span class="line">function handelDomView(key, value, el) &#123;</span><br><span class="line">  let node &#x3D; document.querySelectorAll(&#96;$&#123;el&#125; [data-view &#x3D; $&#123;key&#125;]&#96;);</span><br><span class="line">  node.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    item.innerText &#x3D; value;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新建自己vue类</span><br><span class="line">class myVue &#123;</span><br><span class="line">  constructor(&#123; el, data &#125;) &#123;</span><br><span class="line">    this.el &#x3D; el;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">    &#x2F;&#x2F;分发双向绑定事件，并传入区域块 el</span><br><span class="line">    observable(this.data, el);</span><br><span class="line">    handleDomInput(this.el, this.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据初始化加入-initData"><a href="#数据初始化加入-initData" class="headerlink" title="数据初始化加入 initData"></a>数据初始化加入 initData</h2><p>在 myVue 中将 this.data 拷贝一份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;新建自己vue类</span><br><span class="line">class myVue &#123;</span><br><span class="line">  constructor(&#123; el, data &#125;) &#123;</span><br><span class="line">    this.el &#x3D; el;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">    &#x2F;&#x2F;拷贝</span><br><span class="line">    let initData &#x3D; JSON.parse(JSON.stringify(this.data));</span><br><span class="line">    &#x2F;&#x2F;分发双向绑定事件</span><br><span class="line">    observable(this.data, el, initData);</span><br><span class="line">    handleDomInput(this.el, this.data, initData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在注册双向绑定和分发 input 事件时，进行初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function observable(obj, el, initData) &#123;</span><br><span class="line">  if (!obj || Object.prototype.toString.call(obj) !&#x3D;&#x3D; &#39;[object Object]&#39;) return;</span><br><span class="line">  let keys &#x3D; Object.keys(obj);</span><br><span class="line">  keys.forEach((key) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    handelDomView(key, initData[key], el);</span><br><span class="line">    handleDefine(obj, key, el);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function handleDomInput(el, data, initData) &#123;</span><br><span class="line">  let nodeList &#x3D; document.querySelectorAll(&#96;$&#123;el&#125; [data-model]&#96;);</span><br><span class="line">  nodeList.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    let key &#x3D; item.dataset.model;</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    item.value &#x3D; initData[key];</span><br><span class="line">    item.addEventListener(&#39;input&#39;, function(node) &#123;</span><br><span class="line">      data[key] &#x3D; node.target.value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.html</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;p&gt;name:&lt;span data-view&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;age:&lt;span data-view&#x3D;&quot;age&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    name:&lt;input data-model&#x3D;&quot;name&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">    age:&lt;input data-model&#x3D;&quot;age&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new myVue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: &#39;pipixia&#39;,</span><br><span class="line">      age: 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">myVue.js</span><br><span class="line"></span><br><span class="line">function observable(obj, el, initData) &#123;</span><br><span class="line">  if (!obj || Object.prototype.toString.call(obj) !&#x3D;&#x3D; &#39;[object Object]&#39;) return;</span><br><span class="line">  let keys &#x3D; Object.keys(obj);</span><br><span class="line">  keys.forEach((key) &#x3D;&gt; &#123;</span><br><span class="line">    handelDomView(key, initData[key], el);</span><br><span class="line">    handleDefine(obj, key, el);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleDefine(obj, key, el) &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      return this[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">      handelDomView(key, value, el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取所有的model对象并为它们注册input事件</span><br><span class="line"></span><br><span class="line">function handleDomInput(el, data, initData) &#123;</span><br><span class="line">  let nodeList &#x3D; document.querySelectorAll(&#96;$&#123;el&#125; [data-model]&#96;);</span><br><span class="line">  nodeList.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    let key &#x3D; item.dataset.model;</span><br><span class="line">    item.value &#x3D; initData[key];</span><br><span class="line">    item.addEventListener(&#39;input&#39;, function(node) &#123;</span><br><span class="line">      data[key] &#x3D; node.target.value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取所有的view对象并为他们复职</span><br><span class="line">function handelDomView(key, value, el) &#123;</span><br><span class="line">  let node &#x3D; document.querySelectorAll(&#96;$&#123;el&#125; [data-view &#x3D; $&#123;key&#125;]&#96;);</span><br><span class="line">  node.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    item.innerText &#x3D; value;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新建自己vue类</span><br><span class="line">class myVue &#123;</span><br><span class="line">  constructor(&#123; el, data &#125;) &#123;</span><br><span class="line">    this.el &#x3D; el;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">    &#x2F;&#x2F;分发双向绑定事件</span><br><span class="line">    let initData &#x3D; JSON.parse(JSON.stringify(this.data));</span><br><span class="line">    observable(this.data, el, initData);</span><br><span class="line">    handleDomInput(this.el, this.data, initData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack简易搭建前端vue项</title>
    <url>/pipixia.github.io/2019/12/04/webpack%E7%AE%80%E6%98%93%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AFvue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-webpack-简介"><a href="#1-webpack-简介" class="headerlink" title="1.webpack 简介"></a>1.webpack 简介</h2><p>webpack 是一个前端资源加载和打包工具。所谓的模块就是在平时的前端开发中，用到一些静态资源，如 JavaScript、CSS、图片等文件，webpack 就将这些静态资源文件称之为模块。</p>
<h2 id="2-项目基本结构搭建"><a href="#2-项目基本结构搭建" class="headerlink" title="2.项目基本结构搭建"></a>2.项目基本结构搭建</h2><p><img src="/pipixia.github.io/images/webpack/webpack_vue.png" alt=""></p>
<h3 id="2-1-创建文件如-my-vue"><a href="#2-1-创建文件如-my-vue" class="headerlink" title="2.1 创建文件如 my-vue"></a>2.1 创建文件如 my-vue</h3><p>进入 my-vue 文件夹中按住 shift+鼠标右键 打开 powershell 窗口 输入 npm init 初始化项目 此时会出现一个叫 package.json 的文件</p>
<h3 id="2-2-安装-webpack-对应的插件"><a href="#2-2-安装-webpack-对应的插件" class="headerlink" title="2.2 安装 webpack 对应的插件"></a>2.2 安装 webpack 对应的插件</h3><p>输入下面代码安装 webpack 和 webpack-cli，并在根目录下创建一个 src 的文件夹和一个叫 webpack.config.js 的文件，在文件夹中在创建一个 main.js</p>
<p><code>cnpm i webpack webpack-cli -D</code></p>
<p><img src="/pipixia.github.io/images/webpack/webpack_vue2.png" alt=""></p>
<h3 id="2-3-打开-webpack-config-js-（配置项）"><a href="#2-3-打开-webpack-config-js-（配置项）" class="headerlink" title="2.3 打开 webpack.config.js （配置项）"></a>2.3 打开 webpack.config.js （配置项）</h3><p>在该文件中可以对 webpack 进行一系列的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports &#x3D; (env, argv) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @entry 项目的入口文件,默认为index.js</span><br><span class="line">     *&#x2F;</span><br><span class="line">    entry: path.join(__dirname, &#39;.&#x2F;src&#x2F;main.js&#39;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来点开 <strong>package.json</strong> 文件找到 scripts 并在里面写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --mode development --open&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>并执行下面代码安装 webpack 的热加载模块，让我们的页面可以在我们修改结束后自动刷新<br><code>cnpm i webpack-dev-server -D</code></p>
<h3 id="2-4-安装-babel"><a href="#2-4-安装-babel" class="headerlink" title="2.4 安装 babel"></a>2.4 安装 babel</h3><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line">&quot;babel-loader&quot;: &quot;^7.0.0&quot;,</span><br><span class="line">&quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">&quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">&quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,</span><br></pre></td></tr></table></figure>

<p>安装方法和上面的插件一样<br><code>cnpm i -D babel-core babel-loader babel-plugin-transform-runtime babel-polyfill babel-preset-env</code><br>其中可能会出现安装的版本不同，导致个个插件直接的兼容性不好，这个可以在安装结束根据，给出的警告信息来确定自己要安装哪个版本</p>
<p>然后继续打开<strong>webpack.config.js</strong>文件在里面配置 js 的解析规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports &#x3D; (env, argv) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @entry 项目的入口文件,默认为index.js</span><br><span class="line">     *&#x2F;</span><br><span class="line">    entry: [&#39;babel-polyfill&#39;, path.join(__dirname, &#39;.&#x2F;src&#x2F;main.js&#39;)],</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.js$&#x2F;,</span><br><span class="line">          exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">          use: &#123;</span><br><span class="line">            loader: &#39;babel-loader&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并在<strong>webpack.config.js</strong>同级下面新建.babelrc 并在里面写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-配置-css，图片，html-解析工具"><a href="#2-5-配置-css，图片，html-解析工具" class="headerlink" title="2.5 配置 css，图片，html 解析工具"></a>2.5 配置 css，图片，html 解析工具</h3><p><code>cnpm i -D css-loader postcss-loader style-loader autoprefixer</code> 用于解析 css</p>
<p><code>cnpm i -D html-loader</code> 用于解析 html</p>
<p><code>cnpm i -D file-loader</code> 用于解析图片</p>
<p>然后打开<strong>webpack.config.js</strong>文件在里面配置解析规则</p>
<p>在刚刚的 module 中继续加入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.js$&#x2F;,</span><br><span class="line">          exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">          use: &#123;</span><br><span class="line">            loader: &#39;babel-loader&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.css$&#x2F;,</span><br><span class="line">          use: [</span><br><span class="line">            &#39;style-loader&#39;,</span><br><span class="line">            &#39;css-loader&#39;,</span><br><span class="line">            &#39;postcss-loader&#39;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.html$&#x2F;,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &#39;html-loader&#39;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                minimize: true</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.(png|jpg|gif)$&#x2F;,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &#39;file-loader&#39;,</span><br><span class="line">              options: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>并在<strong>webpack.config.js</strong>同级下面新建<strong>postcss.config.js</strong>并在里面写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-webpack-扩展-plugin"><a href="#2-6-webpack-扩展-plugin" class="headerlink" title="2.6 webpack 扩展 plugin"></a>2.6 webpack 扩展 plugin</h3><p>我们主要用到的插件有<br>MiniCssExtractPlugin（把 css 提取到单独的文件），<br>html-webpack-plugin<br>为 html 文件中引入的外部资源如 script、link 动态添加每次 compile 后的 hash，防止引用缓存的外部文件问题<br>可以生成创建 html 入口文件，比如单页面可以生成一个 html 文件入口，配置 N 个 html-webpack-plugin 可以生成 N 个页面入口<br>CleanWebpackPlugin (清除掉我们打包的生成的文件，dist)</p>
<p><code>cnpm i -D mini-css-extract-plugin html-webpack-plugin clean-webpack-plugin</code></p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line">const HtmlWebPackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line">module.exports &#x3D; (env, argv) &#x3D;&gt; &#123;</span><br><span class="line">  const devMode &#x3D; argv.mode !&#x3D;&#x3D; &#39;production&#39;;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @entry 项目的入口文件,默认为index.js</span><br><span class="line">     *&#x2F;</span><br><span class="line">    entry: [&#39;babel-polyfill&#39;, path.join(__dirname, &#39;.&#x2F;src&#x2F;main.js&#39;)],</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.js$&#x2F;,</span><br><span class="line">          exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">          use: &#123;</span><br><span class="line">            loader: &#39;babel-loader&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.css$&#x2F;,</span><br><span class="line">          use: [</span><br><span class="line">            devMode ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,</span><br><span class="line">            &#39;css-loader&#39;,</span><br><span class="line">            &#39;postcss-loader&#39;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.html$&#x2F;,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &#39;html-loader&#39;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                minimize: true</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: &#x2F;\.(png|jpg|gif)$&#x2F;,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &#39;file-loader&#39;,</span><br><span class="line">              options: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      new CleanWebpackPlugin(),</span><br><span class="line">      new MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: &#39;[name].css&#39;,</span><br><span class="line">        chunkFilename: &#39;[id].css&#39;</span><br><span class="line">      &#125;),</span><br><span class="line">      new HtmlWebPackPlugin(&#123;</span><br><span class="line">        template: &#39;pubilc&#x2F;index.html&#39;,</span><br><span class="line">        filename: &#39;.&#x2F;index.html&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并在项目和 src 同级出建立一个 pubilc 文件夹，在 pubilc 文件夹在创建一个 index.html 作为我们 SPA 的模板界面</p>
<h3 id="2-7-引用-css-和设置快捷访问路径"><a href="#2-7-引用-css-和设置快捷访问路径" class="headerlink" title="2.7 引用 css 和设置快捷访问路径"></a>2.7 引用 css 和设置快捷访问路径</h3><p>在项目 src 下面新建一个 assets 文件用来存放静态文件，然后在 assets 下面在新建一个 css 文件夹，并在 css 中创建一个 index.css<br>用于测试在里面写上一些样式。</p>
<p>回到<strong>webpack.config.js</strong>中，加入下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const resolve &#x3D; (dir) &#x3D;&gt; path.resolve(__dirname, dir);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; (env, argv) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">     resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在回到 main.js 中将我们需要的 css 引入其中,接着 npm run dev 运行项目。<br><code>import &#39;@/assets/css/index.css&#39;;</code></p>
<h2 id="引入-vue"><a href="#引入-vue" class="headerlink" title="引入 vue"></a>引入 vue</h2><p>首先我们安装运行 vue 的插件</p>
<p><code>cnpm i --save vue</code><br><code>cnpm i -D vue-loader vue-template-compiler</code></p>
<p>安装完成后回到<strong>webpack.config.js</strong>中继续配置，加入下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const VueLoaderPlugin &#x3D; require(&#39;vue-loader&#x2F;lib&#x2F;plugin&#39;);</span><br><span class="line">module.exports &#x3D; (env, argv) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    module:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">         &#123;</span><br><span class="line">          test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">          loader: &#39;vue-loader&#39;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            loaders: &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      new CleanWebpackPlugin(),</span><br><span class="line">      new VueLoaderPlugin()</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 src 下面在创建一个 App.vue 的文件,在里面写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    测试</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>并在找到 main.js,写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;@&#x2F;assets&#x2F;css&#x2F;index.css&#39;;</span><br><span class="line">import Vue from &#39;Vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: (h) &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br></pre></td></tr></table></figure>

<p>找到 public 下面的 index.html 写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>接着 npm run dev 运行项目，npm run build 对项目进行打包发布。</p>
<p>路由，vuex，axios，ui 框架，sass，less 都可以用 npm 一点点配置进项目里面。</p>
<p>github 项目链接 <a href="https://github.com/mypipixia/webpack-vue-" target="_blank" rel="noopener">https://github.com/mypipixia/webpack-vue-</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas学习（一）</title>
    <url>/pipixia.github.io/2020/08/23/canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>鼠标事件以及各坐标轴的区别</title>
    <url>/pipixia.github.io/2020/08/23/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%90%84%E5%9D%90%E6%A0%87%E8%BD%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><h3 id="点击事件（onclick）"><a href="#点击事件（onclick）" class="headerlink" title="点击事件（onclick）"></a>点击事件（onclick）</h3><p>鼠标在el元素上时，点击时触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.onclick &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标按下事件（onmousedown）"><a href="#鼠标按下事件（onmousedown）" class="headerlink" title="鼠标按下事件（onmousedown）"></a>鼠标按下事件（onmousedown）</h3><p>鼠标在el元素上时，按下鼠标触发。和click类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.onmousedown &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标松开事件（onmouseup）"><a href="#鼠标松开事件（onmouseup）" class="headerlink" title="鼠标松开事件（onmouseup）"></a>鼠标松开事件（onmouseup）</h3><p>鼠标在el元素上时，松开鼠标触发。和click类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.onmouseup &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标移动事件（onmousemove）"><a href="#鼠标移动事件（onmousemove）" class="headerlink" title="鼠标移动事件（onmousemove）"></a>鼠标移动事件（onmousemove）</h3><p>鼠标在el元素移动时触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.onmousemove &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标进入事件（onmouseover）"><a href="#鼠标进入事件（onmouseover）" class="headerlink" title="鼠标进入事件（onmouseover）"></a>鼠标进入事件（onmouseover）</h3><p>鼠标进入el元素时触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.onmouseover &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标离开事件（onmouseout）"><a href="#鼠标离开事件（onmouseout）" class="headerlink" title="鼠标离开事件（onmouseout）"></a>鼠标离开事件（onmouseout）</h3><p>鼠标离开el元素时触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.onmouseout &#x3D; function(e)&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clientX、offsetX、screenX、pageX、x区别"><a href="#clientX、offsetX、screenX、pageX、x区别" class="headerlink" title="clientX、offsetX、screenX、pageX、x区别"></a>clientX、offsetX、screenX、pageX、x区别</h2><h3 id="clientX、clientY"><a href="#clientX、clientY" class="headerlink" title="clientX、clientY"></a>clientX、clientY</h3><p>鼠标位置距离当前body的距离</p>
<h3 id="pageX、pageY"><a href="#pageX、pageY" class="headerlink" title="pageX、pageY"></a>pageX、pageY</h3><p>鼠标位置距离当前body的位置，包括滚动条</p>
<h3 id="offsetX、offsetY"><a href="#offsetX、offsetY" class="headerlink" title="offsetX、offsetY"></a>offsetX、offsetY</h3><p>鼠标位置距离当前目标元素的位置</p>
<h3 id="screenX、screenY"><a href="#screenX、screenY" class="headerlink" title="screenX、screenY"></a>screenX、screenY</h3><p>鼠标位置距离当前电脑屏幕的位置</p>
<h3 id="x、y"><a href="#x、y" class="headerlink" title="x、y"></a>x、y</h3><p>和screenX、screenY一样</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
</search>
